<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />
<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="author" content="Lincoln Mullen" />

<meta name="date" content="2016-03-28" />

<title>Minhash and locality-sensitive hashing</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>


<link href="data:text/css;charset=utf-8,body%20%7B%0Abackground%2Dcolor%3A%20%23fff%3B%0Amargin%3A%201em%20auto%3B%0Amax%2Dwidth%3A%20700px%3B%0Aoverflow%3A%20visible%3B%0Apadding%2Dleft%3A%202em%3B%0Apadding%2Dright%3A%202em%3B%0Afont%2Dfamily%3A%20%22Open%20Sans%22%2C%20%22Helvetica%20Neue%22%2C%20Helvetica%2C%20Arial%2C%20sans%2Dserif%3B%0Afont%2Dsize%3A%2014px%3B%0Aline%2Dheight%3A%201%2E35%3B%0A%7D%0A%23header%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0A%23TOC%20%7B%0Aclear%3A%20both%3B%0Amargin%3A%200%200%2010px%2010px%3B%0Apadding%3A%204px%3B%0Awidth%3A%20400px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Aborder%2Dradius%3A%205px%3B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Afont%2Dsize%3A%2013px%3B%0Aline%2Dheight%3A%201%2E3%3B%0A%7D%0A%23TOC%20%2Etoctitle%20%7B%0Afont%2Dweight%3A%20bold%3B%0Afont%2Dsize%3A%2015px%3B%0Amargin%2Dleft%3A%205px%3B%0A%7D%0A%23TOC%20ul%20%7B%0Apadding%2Dleft%3A%2040px%3B%0Amargin%2Dleft%3A%20%2D1%2E5em%3B%0Amargin%2Dtop%3A%205px%3B%0Amargin%2Dbottom%3A%205px%3B%0A%7D%0A%23TOC%20ul%20ul%20%7B%0Amargin%2Dleft%3A%20%2D2em%3B%0A%7D%0A%23TOC%20li%20%7B%0Aline%2Dheight%3A%2016px%3B%0A%7D%0Atable%20%7B%0Amargin%3A%201em%20auto%3B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dcolor%3A%20%23DDDDDD%3B%0Aborder%2Dstyle%3A%20outset%3B%0Aborder%2Dcollapse%3A%20collapse%3B%0A%7D%0Atable%20th%20%7B%0Aborder%2Dwidth%3A%202px%3B%0Apadding%3A%205px%3B%0Aborder%2Dstyle%3A%20inset%3B%0A%7D%0Atable%20td%20%7B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dstyle%3A%20inset%3B%0Aline%2Dheight%3A%2018px%3B%0Apadding%3A%205px%205px%3B%0A%7D%0Atable%2C%20table%20th%2C%20table%20td%20%7B%0Aborder%2Dleft%2Dstyle%3A%20none%3B%0Aborder%2Dright%2Dstyle%3A%20none%3B%0A%7D%0Atable%20thead%2C%20table%20tr%2Eeven%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Ap%20%7B%0Amargin%3A%200%2E5em%200%3B%0A%7D%0Ablockquote%20%7B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Apadding%3A%200%2E25em%200%2E75em%3B%0A%7D%0Ahr%20%7B%0Aborder%2Dstyle%3A%20solid%3B%0Aborder%3A%20none%3B%0Aborder%2Dtop%3A%201px%20solid%20%23777%3B%0Amargin%3A%2028px%200%3B%0A%7D%0Adl%20%7B%0Amargin%2Dleft%3A%200%3B%0A%7D%0Adl%20dd%20%7B%0Amargin%2Dbottom%3A%2013px%3B%0Amargin%2Dleft%3A%2013px%3B%0A%7D%0Adl%20dt%20%7B%0Afont%2Dweight%3A%20bold%3B%0A%7D%0Aul%20%7B%0Amargin%2Dtop%3A%200%3B%0A%7D%0Aul%20li%20%7B%0Alist%2Dstyle%3A%20circle%20outside%3B%0A%7D%0Aul%20ul%20%7B%0Amargin%2Dbottom%3A%200%3B%0A%7D%0Apre%2C%20code%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0Aborder%2Dradius%3A%203px%3B%0Acolor%3A%20%23333%3B%0Awhite%2Dspace%3A%20pre%2Dwrap%3B%20%0A%7D%0Apre%20%7B%0Aborder%2Dradius%3A%203px%3B%0Amargin%3A%205px%200px%2010px%200px%3B%0Apadding%3A%2010px%3B%0A%7D%0Apre%3Anot%28%5Bclass%5D%29%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Acode%20%7B%0Afont%2Dfamily%3A%20Consolas%2C%20Monaco%2C%20%27Courier%20New%27%2C%20monospace%3B%0Afont%2Dsize%3A%2085%25%3B%0A%7D%0Ap%20%3E%20code%2C%20li%20%3E%20code%20%7B%0Apadding%3A%202px%200px%3B%0A%7D%0Adiv%2Efigure%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0Aimg%20%7B%0Abackground%2Dcolor%3A%20%23FFFFFF%3B%0Apadding%3A%202px%3B%0Aborder%3A%201px%20solid%20%23DDDDDD%3B%0Aborder%2Dradius%3A%203px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Amargin%3A%200%205px%3B%0A%7D%0Ah1%20%7B%0Amargin%2Dtop%3A%200%3B%0Afont%2Dsize%3A%2035px%3B%0Aline%2Dheight%3A%2040px%3B%0A%7D%0Ah2%20%7B%0Aborder%2Dbottom%3A%204px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Apadding%2Dbottom%3A%202px%3B%0Afont%2Dsize%3A%20145%25%3B%0A%7D%0Ah3%20%7B%0Aborder%2Dbottom%3A%202px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Afont%2Dsize%3A%20120%25%3B%0A%7D%0Ah4%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23f7f7f7%3B%0Amargin%2Dleft%3A%208px%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Ah5%2C%20h6%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23ccc%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Aa%20%7B%0Acolor%3A%20%230033dd%3B%0Atext%2Ddecoration%3A%20none%3B%0A%7D%0Aa%3Ahover%20%7B%0Acolor%3A%20%236666ff%3B%20%7D%0Aa%3Avisited%20%7B%0Acolor%3A%20%23800080%3B%20%7D%0Aa%3Avisited%3Ahover%20%7B%0Acolor%3A%20%23BB00BB%3B%20%7D%0Aa%5Bhref%5E%3D%22http%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0Aa%5Bhref%5E%3D%22https%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0A%0Acode%20%3E%20span%2Ekw%20%7B%20color%3A%20%23555%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Edt%20%7B%20color%3A%20%23902000%3B%20%7D%20%0Acode%20%3E%20span%2Edv%20%7B%20color%3A%20%2340a070%3B%20%7D%20%0Acode%20%3E%20span%2Ebn%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Efl%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Ech%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Est%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Eco%20%7B%20color%3A%20%23888888%3B%20font%2Dstyle%3A%20italic%3B%20%7D%20%0Acode%20%3E%20span%2Eot%20%7B%20color%3A%20%23007020%3B%20%7D%20%0Acode%20%3E%20span%2Eal%20%7B%20color%3A%20%23ff0000%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Efu%20%7B%20color%3A%20%23900%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%20code%20%3E%20span%2Eer%20%7B%20color%3A%20%23a61717%3B%20background%2Dcolor%3A%20%23e3d2d2%3B%20%7D%20%0A" rel="stylesheet" type="text/css" />

</head>

<body>



<div class="fluid-row" id="header">


<h1 class="title">Minhash and locality-sensitive hashing</h1>
<h4 class="author"><em>Lincoln Mullen</em></h4>
<h4 class="date"><em>2016-03-28</em></h4>

</div>


<p>Performing pairwise comparisons in a corpus is time-consuming because the number of comparisons grows geometrically with the size of the corpus. Most of those comparisons, furthermore, are unnecessary because they do not result in matches. The combination of minhash and locality-sensitive hashing (LSH) seeks to solve these problems. They make it possible to compute possible matches only once for each document, so that the cost of computation grows linearly rather than exponentially. This vignette explains how to use the minhash and locality-sensitive hashing functions in this package. For an explanation of why they work, see Jure Leskovec, Anand Rajaraman, and Jeff Ullman, <em><a href="http://www.mmds.org/#book">Mining of Massive Datasets</a></em> (Cambridge University Press, 2011), ch.Â 3. (This <a href="http://matthewcasperson.blogspot.com/2013/11/minhash-for-dummies.html">blog post</a> is a more succinct explanation.)</p>
<p>We begin by creating a minhash function. A minhash function converts tokenized text into a set of hash integers, then selects the minimum value. This is the equivalent of randomly selecting a token. The function then does the same thing repeatedly with different hashing functions, in effect selecting <code>n</code> random shingles. The additional hashing functions come from a bitwise XOR with random integers. That is why the <code>minhash_generator()</code> accepts a seed, so that we can re-create the same minhash function again. In other words, a minhash function converts a set of tokens of any length into <code>n</code> randomly selected and hashed tokens.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(textreuse)
minhash &lt;-<span class="st"> </span><span class="kw">minhash_generator</span>(<span class="dt">n =</span> <span class="dv">240</span>, <span class="dt">seed =</span> <span class="dv">3552</span>)
<span class="kw">head</span>(<span class="kw">minhash</span>(<span class="kw">c</span>(<span class="st">&quot;turn tokens into&quot;</span>, <span class="st">&quot;tokens into hashes&quot;</span>, <span class="st">&quot;into hashes fast&quot;</span>)))</code></pre></div>
<pre><code>## [1] -1067902788  -349477925 -1306490031  -926753052 -1222296305 -1443723653</code></pre>
<p>Now when we load our corpus, we will tokenize our texts as usual, but we will use our generated <code>minhash()</code> function to compute the hashes. We specify that we want to create a minhash signature by passing our minhash function to the <code>minhash_func =</code> parameter.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dir &lt;-<span class="st"> </span><span class="kw">system.file</span>(<span class="st">&quot;extdata/ats&quot;</span>, <span class="dt">package =</span> <span class="st">&quot;textreuse&quot;</span>)
corpus &lt;-<span class="st"> </span><span class="kw">TextReuseCorpus</span>(<span class="dt">dir =</span> dir, <span class="dt">tokenizer =</span> tokenize_ngrams, <span class="dt">n =</span> <span class="dv">5</span>,
                          <span class="dt">minhash_func =</span> minhash, <span class="dt">keep_tokens =</span> <span class="ot">TRUE</span>,
                          <span class="dt">progress =</span> <span class="ot">FALSE</span>)</code></pre></div>
<p>We can verify that we have minhashes in our corpus:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">head</span>(<span class="kw">minhashes</span>(corpus[[<span class="dv">1</span>]]))</code></pre></div>
<pre><code>## [1] -2147421589 -2147475954 -2147470602 -2147373716 -2147464099 -2147477501</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">length</span>(<span class="kw">minhashes</span>(corpus[[<span class="dv">1</span>]]))</code></pre></div>
<pre><code>## [1] 240</code></pre>
<p>Now all our documents are represented by <code>n = 240</code> randomly selected and hashed shingles. Comparing those shingles should be the equivalent of finding the Jaccard similarity of the two documents. However, we still have the problem of pairwise comparison.</p>
<p>The locality-sensitive hashing algorithm, provided in this package by the <code>lsh()</code> function, solves this problem. LSH breaks the minhashes into a series of bands comprised of rows. For example, 200 minhashes might broken into 50 bands of 4 rows each. Each band is hashed to a bucket. If two documents have the exact same minhashes in a band, they will be hashed to the same bucket, and so will be considered candidate pairs. Each pair of documents has as many chances to be considered a candidate as their are bands, and the fewer rows there are in each band, the more likely it is that each document will match another.</p>
<p>How likely is it, then, that we will detect a match? The probability of a match depends on the Jaccard similarity of a pair of documents. The more similar two documents are, the more likely they are to be considered candidates, which is what we want. The probability of a match is an S-curve (see Leskovec, Rajaraman, and Ullman), so there is a threshold Jaccard similarity above which documents are likely to be a match. We can calculate the likely threshold based on the number of minhashes and bands that we are using.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">lsh_threshold</span>(<span class="dt">h =</span> <span class="dv">200</span>, <span class="dt">b =</span> <span class="dv">50</span>)</code></pre></div>
<pre><code>## [1] 0.3760603</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">lsh_threshold</span>(<span class="dt">h =</span> <span class="dv">240</span>, <span class="dt">b =</span> <span class="dv">80</span>)</code></pre></div>
<pre><code>## [1] 0.2320794</code></pre>
<p>Using 240 minhashes and 80 bands, we will likely detect documents with an actual Jaccard similarity of above 0.232. We can also estimate the probability that a pair of documents with a Jaccard similarity <code>s</code> will be marked as potential matches.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">lsh_probability</span>(<span class="dt">h =</span> <span class="dv">240</span>, <span class="dt">b =</span> <span class="dv">80</span>, <span class="dt">s =</span> <span class="fl">0.25</span>)</code></pre></div>
<pre><code>## [1] 0.7163087</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">lsh_probability</span>(<span class="dt">h =</span> <span class="dv">240</span>, <span class="dt">b =</span>  <span class="dv">80</span>, <span class="dt">s =</span> <span class="fl">0.75</span>)</code></pre></div>
<pre><code>## [1] 1</code></pre>
<p>These numbers seem reasonable for our purposes, so we will set the number of minhashes at 240 and the number of bands at 80.</p>
<p>Now we can use the <code>lsh()</code> function to calculate the locality-sensitive hashes for our documents.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">buckets &lt;-<span class="st"> </span><span class="kw">lsh</span>(corpus, <span class="dt">bands =</span> <span class="dv">80</span>, <span class="dt">progress =</span> <span class="ot">FALSE</span>)
buckets</code></pre></div>
<pre><code>## Source: local data frame [640 x 2]
## 
##                   doc                          buckets
##                 &lt;chr&gt;                            &lt;chr&gt;
## 1  calltounconv00baxt 47c0a03caefcafe1749399b967583925
## 2  calltounconv00baxt 7e0f2ae5f606bbae2085966065505057
## 3  calltounconv00baxt 4ce11e168463662547df79f0c1c52ba3
## 4  calltounconv00baxt 1197924ad432897b8f89643c35077c66
## 5  calltounconv00baxt b4fedffa4a13bc7b36c91eefb8c3c452
## 6  calltounconv00baxt 43415e07b892397e336a382c386fcad6
## 7  calltounconv00baxt 693ab22baa328a19b795278aa5e4abc2
## 8  calltounconv00baxt 339a856bb257af23432f0bd64283a021
## 9  calltounconv00baxt 3984470289474583507ee2ad1cc26118
## 10 calltounconv00baxt 3ccdda855b41b7d695169a32ec4ceded
## ..                ...                              ...</code></pre>
<p>Note that using the LSH method only requires us to calculate the signatures (or buckets) for each document one time. This implies that we can take several data frames of LSH signatures and bind their rows together (e.g., with <code>dplyr::bind_rows()</code>). This permits us to compute the signatures for only part of a corpus at a time, or to continue to add to the corpus. Note, however, that you <strong>must</strong> use the same minhash function, generating the same number of minhashes and using the same seed and you <strong>must</strong> use the same number of bands in order to get valid results.</p>
<p>We can extract the potential matches from the cache using <code>lsh_query()</code> or <code>lsh_candidates()</code>. The first function returns matches for only one document, specified by its ID; the second functions returns all potential pairs of matches.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">baxter_matches &lt;-<span class="st"> </span><span class="kw">lsh_query</span>(buckets, <span class="st">&quot;calltounconv00baxt&quot;</span>)
baxter_matches</code></pre></div>
<pre><code>## Source: local data frame [1 x 2]
## 
##                    a                      b
##                &lt;chr&gt;                  &lt;chr&gt;
## 1 calltounconv00baxt lifeofrevrichard00baxt</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">candidates &lt;-<span class="st"> </span><span class="kw">lsh_candidates</span>(buckets)
candidates</code></pre></div>
<pre><code>## Source: local data frame [3 x 3]
## 
##                       a                      b score
##                   &lt;chr&gt;                  &lt;chr&gt; &lt;dbl&gt;
## 1    calltounconv00baxt lifeofrevrichard00baxt    NA
## 2 practicalthought00nev thoughtsonpopery00nevi    NA
## 3        remember00palm remembermeorholy00palm    NA</code></pre>
<p>Notice that LSH has identified the same three pairs of documents as potential matches that we found with pairwise comparisons, but did so much faster. But we do not have similarity scores; we only know that these documents are likely to have Jaccard similarity scores above the 0.232 threshold.</p>
<p>Now we can use <code>lsh_compare()</code> to apply a similarity function to the candidate pairs of documents. Note that we only have to do 3 comparisons for all the candidates, instead of 28 pairs when comparing all 8 documents in the corpus pairwise.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">lsh_compare</span>(candidates, corpus, jaccard_similarity, <span class="dt">progress =</span> <span class="ot">FALSE</span>)</code></pre></div>
<pre><code>## Source: local data frame [3 x 3]
## 
##                       a                      b     score
##                   &lt;chr&gt;                  &lt;chr&gt;     &lt;dbl&gt;
## 1    calltounconv00baxt lifeofrevrichard00baxt 0.2807016
## 2 practicalthought00nev thoughtsonpopery00nevi 0.4629868
## 3        remember00palm remembermeorholy00palm 0.7006189</code></pre>
<p>Note that these results are identical to what we calculated in the pairwise vignette, but required much less computation.</p>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
